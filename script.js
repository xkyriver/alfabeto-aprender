/*
 * Alfabeto Aprender - Jogo Educativo Interativo
 * Autor: xkyriver
 * Vers√£o: 1.1.0
 * Licen√ßa: MIT
 * 
 * Jogo interativo para crian√ßas aprenderem o alfabeto portugu√™s
 * com som, anima√ß√µes e feedback visual.
 * 
 * Vers√£o 1.1.0: Implementa√ß√£o de Google TTS para letra O
 */

// Estado do jogo
class AlphabetGame {
    constructor() {
        this.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        this.remainingLetters = [...this.alphabet];
        this.currentLetter = null;
        this.isGameActive = false;
        this.speechSynthesis = window.speechSynthesis;
        this.speechUtterance = null;
        
        this.initializeElements();
        this.setupEventListeners();
        this.createLetterCards();
        this.checkSpeechSupport();
    }

    initializeElements() {
        this.elements = {
            startButton: document.getElementById('startButton'),
            resetButton: document.getElementById('resetButton'),
            speakButton: document.getElementById('speakButton'),
            playAgainButton: document.getElementById('playAgainButton'),
            lettersGrid: document.getElementById('lettersGrid'),
            letterDisplay: document.getElementById('letterDisplay'),
            instructionText: document.getElementById('instructionText'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            celebrationOverlay: document.getElementById('celebrationOverlay'),
            feedback: document.getElementById('feedback')
        };
    }

    setupEventListeners() {
        this.elements.startButton.addEventListener('click', () => this.startGame());
        this.elements.resetButton.addEventListener('click', () => this.resetGame());
        this.elements.speakButton.addEventListener('click', () => this.speakCurrentLetter());
        this.elements.playAgainButton.addEventListener('click', () => this.resetGame());
        
        // Adicionar listener para quando a s√≠ntese de voz termina
        if (this.speechSynthesis) {
            this.speechSynthesis.addEventListener('voiceschanged', () => {
                this.checkSpeechSupport();
            });
        }
    }

    checkSpeechSupport() {
        if (!this.speechSynthesis) {
            console.warn('Speech synthesis n√£o suportado neste navegador');
            this.elements.speakButton.style.display = 'none';
            return false;
        }
        
        // Verificar se h√° vozes dispon√≠veis
        const voices = this.speechSynthesis.getVoices();
        console.log('Vozes dispon√≠veis:', voices.length);
        
        if (voices.length === 0) {
            // Aguardar carregamento das vozes
            setTimeout(() => this.checkSpeechSupport(), 100);
            return false;
        }
        
        // Procurar voz portuguesa
        this.selectedVoice = voices.find(voice => 
            voice.lang.startsWith('pt') || voice.lang.includes('pt-PT') || voice.lang.includes('pt-BR')
        ) || voices.find(voice => 
            voice.lang.startsWith('en') // Fallback para ingl√™s se n√£o houver portugu√™s
        ) || voices[0]; // √öltima op√ß√£o: primeira voz dispon√≠vel
        
        console.log('Voz selecionada:', this.selectedVoice ? this.selectedVoice.name : 'Nenhuma');
        return true;
    }

    createLetterCards() {
        this.elements.lettersGrid.innerHTML = '';
        
        this.alphabet.forEach(letter => {
            const card = document.createElement('div');
            card.className = 'letter-card';
            card.textContent = letter;
            card.dataset.letter = letter;
            
            card.addEventListener('click', () => this.handleLetterClick(letter, card));
            
            // Adicionar suporte para touch
            card.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevenir zoom em dispositivos touch
                this.handleLetterClick(letter, card);
            });
            
            this.elements.lettersGrid.appendChild(card);
        });
    }

    startGame() {
        this.isGameActive = true;
        this.remainingLetters = [...this.alphabet];
        
        // Mostrar/ocultar bot√µes
        this.elements.startButton.style.display = 'none';
        this.elements.resetButton.style.display = 'inline-block';
        this.elements.speakButton.style.display = 'inline-block';
        
        // Restaurar todos os cart√µes
        const cards = document.querySelectorAll('.letter-card');
        cards.forEach(card => {
            card.classList.remove('hidden', 'correct', 'wrong');
            card.style.display = 'flex';
        });
        
        // Atualizar progresso
        this.updateProgress();
        
        // Come√ßar primeira rodada
        this.nextRound();
    }

    nextRound() {
        if (this.remainingLetters.length === 0) {
            this.gameComplete();
            return;
        }
        
        // Escolher letra aleat√≥ria
        const randomIndex = Math.floor(Math.random() * this.remainingLetters.length);
        this.currentLetter = this.remainingLetters[randomIndex];
        
        // Atualizar display
        this.elements.letterDisplay.textContent = this.currentLetter;
        this.elements.instructionText.textContent = `Encontra a letra "${this.currentLetter}"!`;
        
        // Falar a letra ap√≥s um pequeno atraso
        setTimeout(() => {
            this.speakCurrentLetter();
        }, 500);
    }

    handleLetterClick(clickedLetter, cardElement) {
        if (!this.isGameActive) return;
        
        if (clickedLetter === this.currentLetter) {
            // Resposta correta
            this.handleCorrectAnswer(cardElement);
        } else {
            // Resposta incorreta
            this.handleWrongAnswer(cardElement);
        }
    }

    handleCorrectAnswer(cardElement) {
        // Anima√ß√£o de sucesso
        cardElement.classList.add('correct');
        
        // Remover letra da lista
        this.remainingLetters = this.remainingLetters.filter(letter => letter !== this.currentLetter);
        
        // Feedback visual
        this.showFeedback('üéâ Muito bem!', 'correct');
        
        // Som de sucesso (usando Web Audio API se dispon√≠vel)
        this.playSuccessSound();
        
        // Atualizar progresso
        this.updateProgress();
        
        // Ocultar cart√£o ap√≥s anima√ß√£o
        setTimeout(() => {
            cardElement.classList.add('hidden');
            cardElement.style.display = 'none';
        }, 600);
        
        // Pr√≥xima rodada ap√≥s delay
        setTimeout(() => {
            this.nextRound();
        }, 1500);
    }

    handleWrongAnswer(cardElement) {
        // Anima√ß√£o de erro
        cardElement.classList.add('wrong');
        
        // Feedback visual
        this.showFeedback('‚ùå Tenta outra vez!', 'wrong');
        
        // Som de erro
        this.playErrorSound();
        
        // Remover classe ap√≥s anima√ß√£o
        setTimeout(() => {
            cardElement.classList.remove('wrong');
        }, 500);
        
        // Repetir a letra ap√≥s erro
        setTimeout(() => {
            this.speakCurrentLetter();
        }, 1000);
    }

    showFeedback(message, type) {
        this.elements.feedback.textContent = message;
        this.elements.feedback.className = `feedback ${type}`;
        
        // Remover feedback ap√≥s anima√ß√£o
        setTimeout(() => {
            this.elements.feedback.textContent = '';
            this.elements.feedback.className = 'feedback';
        }, 1000);
    }

    updateProgress() {
        const completed = this.alphabet.length - this.remainingLetters.length;
        const percentage = (completed / this.alphabet.length) * 100;
        
        this.elements.progressFill.style.width = `${percentage}%`;
        this.elements.progressText.textContent = `${this.remainingLetters.length} letra${this.remainingLetters.length !== 1 ? 's' : ''} restante${this.remainingLetters.length !== 1 ? 's' : ''}`;
    }

    speakCurrentLetter() {
        if (!this.speechSynthesis || !this.currentLetter) {
            console.log('Speech synthesis n√£o dispon√≠vel ou letra n√£o definida');
            return;
        }
        
        // Parar qualquer s√≠ntese anterior
        this.speechSynthesis.cancel();
        
        // Aguardar um pouco para garantir que parou
        setTimeout(() => {
            // Estrat√©gia especial para o U - tentar m√∫ltiplas variantes
            if (this.currentLetter === 'U') {
                this.speakLetterU();
                return;
            }
            
            // Estrat√©gia especial para o O - usar Google TTS PT-PT
            if (this.currentLetter === 'O') {
                this.speakLetterO();
                return;
            }
            
            // Mapeamento de pron√∫ncia correta para portugu√™s europeu
            const pronunciationMap = {
                'A': '√°',      // Som "√°" (vamos usar configura√ß√µes para arrastar)
                'E': '√©',      // Som "√©" em vez de "i"
                'I': '√≠',      // Som "√≠" 
                'O': '√≥'       // Som "√≥" (vamos usar configura√ß√µes para arrastar)
            };
            
            // Usar pronuncia√ß√£o customizada para vogais ou letra original para consoantes
            const textToSpeak = pronunciationMap[this.currentLetter] || this.currentLetter;
            
            // Criar nova utterance com texto corrigido
            this.speechUtterance = new SpeechSynthesisUtterance(textToSpeak);
            
            // Usar voz selecionada se dispon√≠vel
            if (this.selectedVoice) {
                this.speechUtterance.voice = this.selectedVoice;
                console.log('Usando voz:', this.selectedVoice.name);
            }
            
            // Configura√ß√µes de fala otimizadas para vogais
            if (pronunciationMap[this.currentLetter]) {
                if (this.currentLetter === 'U') {
                    // Configura√ß√µes especiais para U (mais aud√≠vel)
                    this.speechUtterance.rate = 0.15; // Ainda mais lento para U
                    this.speechUtterance.pitch = 1.3; // Tom mais alto para U
                } else {
                    // Configura√ß√µes para outras vogais
                    this.speechUtterance.rate = 0.2;  // Extremamente lento para vogais
                    this.speechUtterance.pitch = 1.1; // Tom ligeiramente mais baixo
                }
            } else {
                // Configura√ß√µes normais para consoantes
                this.speechUtterance.rate = 0.7;
                this.speechUtterance.pitch = 1.3;
            }
            
            this.speechUtterance.volume = 1.0; // Volume m√°ximo
            this.speechUtterance.lang = 'pt-PT'; // For√ßar idioma portugu√™s
            
            // Logs para debug
            console.log('Falando letra:', this.currentLetter, '‚Üí', textToSpeak);
            console.log('Configura√ß√µes:', {
                rate: this.speechUtterance.rate,
                pitch: this.speechUtterance.pitch,
                volume: this.speechUtterance.volume,
                lang: this.speechUtterance.lang
            });
            
            // Eventos para debug
            this.speechUtterance.onstart = () => console.log('Speech iniciado');
            this.speechUtterance.onend = () => console.log('Speech terminado');
            this.speechUtterance.onerror = (e) => {
                console.error('Erro na s√≠ntese de voz:', e);
                // Fallback: mostrar alerta com a letra
                this.showLetterFallback();
            };
            
            // Falar sem retry autom√°tico
            try {
                this.speechSynthesis.speak(this.speechUtterance);
            } catch (error) {
                console.error('Erro ao tentar falar:', error);
                this.showLetterFallback();
            }
        }, 100);
    }
    
    // M√©todo especializado para o U - usando configura√ß√£o escolhida: U4 - Ditongo
    speakLetterU() {
        console.log('üéØ Reproduzindo letra U com configura√ß√£o otimizada: U4 - Ditongo');
        
        // Usar a configura√ß√£o testada e aprovada: "ou" (ditongo portugu√™s)
        const textToSpeak = 'ou';
        
        this.speechUtterance = new SpeechSynthesisUtterance(textToSpeak);
        
        // Usar voz selecionada se dispon√≠vel
        if (this.selectedVoice) {
            this.speechUtterance.voice = this.selectedVoice;
        }
        
        // Configura√ß√µes espec√≠ficas do U4 - Ditongo
        this.speechUtterance.rate = 0.15;  // Velocidade do teste U4
        this.speechUtterance.pitch = 1.1;  // Tom do teste U4
        this.speechUtterance.volume = 1.0; // Volume m√°ximo
        this.speechUtterance.lang = 'pt-PT';
        
        // Event handlers (sem timeout problem√°tico)
        this.speechUtterance.onstart = () => {
            console.log('üéØ Iniciando reprodu√ß√£o: U4 - Ditongo ("ou")');
        };
        
        this.speechUtterance.onend = () => {
            console.log('üéØ U4 - Ditongo reproduzido com sucesso');
        };
        
        this.speechUtterance.onerror = (e) => {
            console.error('üéØ Erro na reprodu√ß√£o do U4 - Ditongo:', e);
            // S√≥ usar fallback se realmente houve erro cr√≠tico
            if (e.error && e.error !== 'interrupted' && e.error !== 'canceled') {
                console.log('üéØ Usando fallback Web Audio devido ao erro cr√≠tico:', e.error);
                this.speakLetterUWithAudio();
            } else {
                console.log('üéØ Erro ignorado (interrupted/canceled):', e.error);
            }
        };
        
        // Reproduzir a configura√ß√£o escolhida (sem timeout)
        try {
            this.speechSynthesis.speak(this.speechUtterance);
        } catch (error) {
            console.error('üéØ Exce√ß√£o ao reproduzir U4 - Ditongo:', error);
            // Fallback para Web Audio API apenas em caso de exce√ß√£o real
            this.speakLetterUWithAudio();
        }
    }
    
    // M√©todo especializado para o O - usando Google TTS PT-PT
    speakLetterO() {
        console.log('üåê Reproduzindo letra O com Google TTS PT-PT: O56');
        
        // Criar elemento de √°udio para Google TTS
        const audioElement = new Audio();
        const textToSpeak = '√≥';
        const encodedText = encodeURIComponent(textToSpeak);
        const googleTTSUrl = `https://translate.google.com/translate_tts?ie=UTF-8&tl=pt&client=tw-ob&q=${encodedText}`;
        
        audioElement.src = googleTTSUrl;
        audioElement.volume = 1.0;
        
        audioElement.onloadstart = () => {
            console.log('üåê Carregando Google TTS para letra O...');
        };
        
        audioElement.onplay = () => {
            console.log('üåê Google TTS O56 iniciado: "√≥" (pt-PT)');
        };
        
        audioElement.onended = () => {
            console.log('üåê Google TTS O56 conclu√≠do com sucesso');
        };
        
        audioElement.onerror = (error) => {
            console.error('üåê Erro Google TTS O56:', error);
            console.log('üåê Usando fallback para s√≠ntese local...');
            // Fallback para s√≠ntese local
            this.speakLetterOFallback();
        };
        
        try {
            audioElement.play();
        } catch (error) {
            console.error('üåê Erro ao reproduzir Google TTS O56:', error);
            // Fallback para s√≠ntese local
            this.speakLetterOFallback();
        }
    }
    
    // Fallback para letra O usando s√≠ntese local
    speakLetterOFallback() {
        console.log('üîÑ Usando fallback local para letra O');
        
        this.speechUtterance = new SpeechSynthesisUtterance('√≥');
        
        if (this.selectedVoice) {
            this.speechUtterance.voice = this.selectedVoice;
        }
        
        // Configura√ß√µes otimizadas para O
        this.speechUtterance.rate = 0.2;
        this.speechUtterance.pitch = 1.1;
        this.speechUtterance.volume = 1.0;
        this.speechUtterance.lang = 'pt-PT';
        
        this.speechUtterance.onstart = () => {
            console.log('üîÑ Fallback local O iniciado');
        };
        
        this.speechUtterance.onend = () => {
            console.log('üîÑ Fallback local O conclu√≠do');
        };
        
        this.speechUtterance.onerror = (e) => {
            console.error('üîÑ Erro no fallback local O:', e);
        };
        
        try {
            this.speechSynthesis.speak(this.speechUtterance);
        } catch (error) {
            console.error('üîÑ Exce√ß√£o no fallback local O:', error);
        }
    }
    
    // Fallback usando Web Audio API para criar som do U artificialmente
    speakLetterUWithAudio() {
        console.log('üéµ Criando som do U com Web Audio API');
        
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Criar som vowel-like para U (som grave e prolongado)
            const duration = 1.5; // 1.5 segundos
            const startTime = audioContext.currentTime;
            
            // Frequ√™ncia fundamental para som de U (aproximadamente 300Hz)
            const fundamentalFreq = 300;
            
            // Criar harm√¥nicos para som mais natural
            const harmonics = [
                { freq: fundamentalFreq, gain: 0.8 },      // Fundamental
                { freq: fundamentalFreq * 2, gain: 0.4 },  // 2¬™ harm√¥nica
                { freq: fundamentalFreq * 3, gain: 0.2 },  // 3¬™ harm√¥nica
                { freq: fundamentalFreq * 4, gain: 0.1 }   // 4¬™ harm√¥nica
            ];
            
            harmonics.forEach((harmonic, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                // Conectar: oscillator ‚Üí filter ‚Üí gain ‚Üí destination
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Configurar oscilador
                oscillator.frequency.value = harmonic.freq;
                oscillator.type = 'sine';
                
                // Configurar filtro para som mais natural
                filter.type = 'lowpass';
                filter.frequency.value = 800; // Cortar frequ√™ncias agudas
                filter.Q.value = 1;
                
                // Envelope de amplitude (fade in/out)
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(harmonic.gain, startTime + 0.1);
                gainNode.gain.linearRampToValueAtTime(harmonic.gain * 0.8, startTime + duration - 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                
                // Iniciar e parar
                oscillator.start(startTime);
                oscillator.stop(startTime + duration);
            });
            
            // Mostrar feedback visual
            this.showFeedback('üéµ Letra U (√°udio sint√©tico)', 'correct');
            
            console.log('üéµ Som do U criado artificialmente');
            
        } catch (e) {
            console.error('üéµ Erro ao criar som do U com Web Audio API:', e);
            // Fallback final
            this.showLetterFallback();
        }
    }
    
    showLetterFallback() {
        // Mostrar letra visualmente como fallback
        this.showFeedback(`üì¢ Letra: ${this.currentLetter}`, 'correct');
    }

    playSuccessSound() {
        // Criar som usando Web Audio API
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Resumir contexto se estiver suspenso (pol√≠tica de autoplay)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Criar sequ√™ncia de notas alegres
            const notes = [523.25, 659.25, 783.99]; // D√≥, Mi, Sol
            
            notes.forEach((frequency, index) => {
                setTimeout(() => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    // Volume mais alto
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.6, audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.4);
                }, index * 120);
            });
        } catch (e) {
            console.log('Web Audio API n√£o dispon√≠vel:', e);
        }
    }

    playErrorSound() {
        // Som simples de erro
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Resumir contexto se estiver suspenso
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 200; // Frequ√™ncia baixa
            oscillator.type = 'sawtooth';
            
            // Volume mais alto
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.4, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.4);
        } catch (e) {
            console.log('Web Audio API n√£o dispon√≠vel:', e);
        }
    }

    gameComplete() {
        this.isGameActive = false;
        
        // Mostrar celebra√ß√£o
        this.elements.celebrationOverlay.style.display = 'flex';
        
        // Tocar som de vit√≥ria
        this.playVictorySound();
        
        // Ocultar bot√µes do jogo
        this.elements.speakButton.style.display = 'none';
        this.elements.resetButton.style.display = 'none';
        
        // Atualizar display
        this.elements.letterDisplay.textContent = 'üéâ';
        this.elements.instructionText.textContent = 'Parab√©ns! Completaste o alfabeto!';
    }

    playVictorySound() {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Melodia de vit√≥ria
            const melody = [
                { freq: 523.25, duration: 0.2 }, // D√≥
                { freq: 659.25, duration: 0.2 }, // Mi
                { freq: 783.99, duration: 0.2 }, // Sol
                { freq: 1046.5, duration: 0.4 }  // D√≥ oitava
            ];
            
            let startTime = audioContext.currentTime;
            
            melody.forEach((note, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = note.freq;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + note.duration);
                
                startTime += note.duration;
            });
        } catch (e) {
            console.log('Web Audio API n√£o dispon√≠vel');
        }
    }

    resetGame() {
        this.isGameActive = false;
        this.remainingLetters = [...this.alphabet];
        this.currentLetter = null;
        
        // Ocultar celebra√ß√£o
        this.elements.celebrationOverlay.style.display = 'none';
        
        // Restaurar bot√µes
        this.elements.startButton.style.display = 'inline-block';
        this.elements.resetButton.style.display = 'none';
        this.elements.speakButton.style.display = 'none';
        
        // Restaurar display inicial
        this.elements.letterDisplay.textContent = '?';
        this.elements.instructionText.textContent = 'Clica em "Come√ßar" para iniciares o jogo!';
        
        // Restaurar progresso
        this.elements.progressFill.style.width = '0%';
        this.elements.progressText.textContent = '26 letras restantes';
        
        // Parar s√≠ntese de voz
        if (this.speechSynthesis) {
            this.speechSynthesis.cancel();
        }
        
        // Recrear cart√µes
        this.createLetterCards();
    }
}

// Inicializar jogo quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', () => {
    const game = new AlphabetGame();
    
    // Adicionar suporte para dispositivos touch
    document.addEventListener('touchstart', function() {}, true);
    
    // Prevenir zoom em dispositivos m√≥veis
    document.addEventListener('touchmove', function(e) {
        if (e.scale !== 1) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Detector de combina√ß√µes secretas
    let secretSequence = '';
    
    document.addEventListener('keydown', (e) => {
        // Adicionar tecla √† sequ√™ncia
        secretSequence += e.key.toLowerCase();
        
        // Manter apenas os √∫ltimos 6 caracteres
        if (secretSequence.length > 6) {
            secretSequence = secretSequence.slice(-6);
        }
        
        // C√≥digo "rabbit" - Backdoor completo
        if (secretSequence === 'rabbit') {
            console.log('üîç C√≥digo "rabbit" detetado! Abrindo backdoor completo...');
            window.open('backdoor.html', '_blank', 'width=1200,height=800');
            secretSequence = '';
        }
        
    });
    
    // Adicionar indicador de carregamento de vozes
    if ('speechSynthesis' in window) {
        // Aguardar carregamento das vozes
        const checkVoices = () => {
            const voices = speechSynthesis.getVoices();
            if (voices.length > 0) {
                console.log('Vozes carregadas:', voices.filter(v => v.lang.includes('pt')).length, 'vozes portuguesas encontradas');
            } else {
                setTimeout(checkVoices, 100);
            }
        };
        checkVoices();
    }
    
    console.log('üéØ Jogo do Alfabeto inicializado com sucesso! - Vers√£o 1.1.0');
    console.log('‚úÖ Letra U configurada: U4 - Ditongo ("ou") - Rate: 0.15, Pitch: 1.1');
    console.log('üåê Letra O configurada: Google TTS PT-PT ("√≥") com fallback local');
    console.log('üîë C√≥digo secreto dispon√≠vel:');
    console.log('  - "rabbit" ‚Üí Backdoor para testes de som');
});
